/**
 * Created by as on 2017/5/21.
 */
/*
* 语句、表达式和运算符
*
* - 保留字(reserved word)
*   null true false - 字面量
*   - 关键字
*     break do instanceof typeof case else new var catch finally return void continue for switch
*     while default if throw delete in try
*   - 今后的保留字
*     class enum extends super const export import implements let provate public yield interface
*     package protected statics
* - 标识符
*   标识符是开发者在程序中所定义的单词，例如变量名或是函数名。
*   命名规则:
*   - 必须是除保留字以外的单词
*   - 必须是除true、false、null意外的单词
*   - 必须是以Unicode的(非空)字符开始，之后接有Unicode字符或是数字的单词
*   - 单词的长度并无限制
* - 字面量
*   字面量(literal)指的是，在代码中写下这些值之后，将会在运行时直接使用这些值的字面含义。
*    //字符串字面量"bar"的例子
*    var foo = "bar";
*
*   数值     100
*   字符串值  "foobar"
*   布尔值    true
*   null值   null
*   Object   {x:1, y:2}
*   数列      [3,2,1]
*   函数      function() {return 0;}
*   正则表达式 /foo/
* - 语句(statement)
* - ...
* - for in 语句
*   用于枚举对象属性名的循环语句
*   for(变量 in 对象表达式)
*     语句
*   in的左侧是在语句中供赋值的表达式，能够在循环式对其进行操作。这个变量也可以称为循环变量。
*   in的右侧是Object类型的表达式。
*   var obj = {x:1, y:2,z:3};
*   for(var k in obj){
*     print(obj); // output : x y z
*     print(obj[k]); // output : 1 2 3
*   }
* - 数列和for in 语句
*   由于数列也是对象，且其下标数值相当于一种属性名，所以也可以向下面这样通过for...in语句实现枚举。不过并不推荐这种方式对数列进行枚举
*   // 枚举数列的元素
*   var arr = [1,2,3];
*   for(var n in arr){
*     print(n); // 数组元素的下标
*     print(arr[n]); // 数组中位于n位置的元素
*   }
*   Note: for...in 使用注意
*     枚举属性的顺序（不一定存在枚举顺序关系的问题）
*     无法被枚举的属性（如length是一种无法被for.in枚举的属性）
*     由原型继承而来的属性（for.in语句还可以枚举由原型继承而来的属性）
* - for each in 语句
*   在ECMAScript中并不存在，是JavaScript自有的增强功能。
*     for each (变量 in 对象表达式)
*       语句
*   和for.in语句不同，for each in语句并不是把属性名赋值给变量，而是将属性值赋值给变量。
*     for each (var k in obj){
*       print(k); // output: 1 2 3
*     }
* - break语句
*   在循环中有时需要中途跳出循环，为此可以使用break语句。break语句不仅可以跳出switch-case语句的循环，也能够用于其他类型的循环语句。
*     // 不通过break语句跳出循环的代码示例
*     var flag_loop = true;
*     while(flag_loop){
*       省略
*       if(跳出循环的条件){
*         flag_loop = false;
*       }
*     }
*     // 通过break语句跳出循环的代码示例
*     while(true){
*       省略
*       if(跳出循环的条件){
*         break;
*       }
*     }
* - continue 语句
*   在循环中使用continue语句的话，就会跳过再次之后本次循环内尚未执行的语句，而返回至循环的条件表达式进行求值。如果是for语句的情况，
*   则是返回至更新表达式处求值后在对条件表达式进行求值。更直接点说，就是continue语句将会跳转至循环的开头。
*     // 仅当循环变量为偶数是才进行处理的for循环
*     for(var i=0; i<10; i++){
*       if(i % 2 == 0){
*         处理
*       }
*     }
*     // 仅当循环变量为偶数时才进行处理的for循环(采用continue的版本)
*     for(var i=0; i<10; i++){
*       if(i % 2 != 0){
*         continue;
*       }
*       处理
*     }
* - 通过标签跳转
*   在嵌套循环的内层使用break语句的话，仅仅会跳出内层的循环。
*   // 在嵌套循环的内层使用break语句的代码示例，仅仅跳出内层循环
*   while(条件表达式){
*     print("outer loop");
*     while(条件表达式){
*       print("inner loop");
*       if(跳出循环的条件){
*         break;
*       }
*     }
*   }
*   那么如何才能同事跳出外层循环呢？从理论上来说，可以像下面这样通过旗标变量来实现，但是这样的代码不易改动。所以并不推荐。
*   // 同时跳出嵌套内外层的循环（采用了旗标变量的版本，并不推荐）
*   var flag_loop = true;
*   while(flag_loop){
*     print("outer loop");
*     while(条件表达式){
*       print("inner loop");
*       if(跳出循环的条件){
*         flag_loop = false;// 这样就能同时跳出外层循环
*         break;
*       }
*     }
*     flag_loop 变量变为了false之后，将会跳过这一部分代码。
*   }
*
*   // 标签语法规则
*   标签字符串 : 语句
*   // 使用标签来同时跳出嵌套的循环
*   outer_loop:
*   while(true){
*     print("outer loop");
*     while(true){
*       print("inner loop");
*       break outer_loop;
*     }
*   }
* - return 语句
*   如果没有指定表达式，函数的返回值将会是undefined值。
* - 异常
*   可以通过throw语句来跑出异常对象(异常值)。
*   // throw语句的语法规则
*   throw 表达式;
*   try...catch...finally
*   try {
*     语句
*   } catch(变量名){ // 该变量是一个引用了所捕捉到的一场对象的局部变量
*     语句
*   } finally{
*     语句
*   }
*   如果在try字句中发生异常的话，运行就会终端，并开始执行catch字句的部分。执行catch字句被称为捕捉到了异常。finally语句必定会在跳出try
*   语句之时被执行。及时没有产生异常，finally字句也会被执行。
*     try{
*       print("try");
*       null.x;  // 在此处强制产生一个TypeError异常
*       print("not here"); // 这条语句不会被执行
*     } catch(e){  // 对象e是TypeError对象的一个引用
*       print("catch");
*     } finally{
*       print("finally");
*     }
* - 其他
*   - with语句
*     with语句用于临时改变名称(变量名或是函数名)的查找范围。with语句中使用的表达式是Object类型的。如果使用了其他类型的值，
*     则会被转换为Object类型。在with语句内对变量名进行查找时，将会从所指定对象的属性开始寻找。
*     // with语句的例子
*     var x = 7; // 全局变量
*     var obj = {x:1,y:2};
*     with(obj){
*       print(x); // 如果要查找变量x，则会在查找全局变量x之前查找到obj.x
*     }
*     Note: 在ECMAScript第5版本的strict模式中是进制使用with语句的。
* - 表达式
* - 运算符
* - 表达式求值
*   - 除了包含&&运算符、||运算符、?:运算符这三个运算符的情况外，其他的表达式都是首先对操作数进行求值。
*   - 操作数按从左向右的顺序求值
*   - 对于函数方法或是构造函数调用表达式的情况，会在调用前对参数从左至右求值
*   - 优先对括号内的表达式求值
*   - 如果在对操作数求值的过程中产生了异常，则不会对生育的操作数进行求值
*   - 对于函数方法或是构造函数调用表达式的情况，如果在对参数进行求值的过程中发生异常，则不会对生育的参数进行求值
* - 运算符的优先级及结合规律
*   - 前置单目运算符是右结合的
*   - 后置单目运算符是左结合的
*   - 除赋值运算符之外的双目运算符都是左结合的
*   - 赋值运算符是右结合的
*   - 三目运算符是右结合的
* - 算术运算符
* - 字符串连接运算符
* - 相等运算符
*   === or ==    !== or !=
*   ===  strict Equals == Equals
*   - x与y如果数据类型不相符，则结果为假
*   - 两者都是undefined值或两者都是null值的情况，结果为真
*   - 两者都是数值，但有一方为NaN，或者两者都是NaN的情况，结果为假。否则，如果数值相等则结果为真，不相等则为假。
*   - 两者都是字符串的情况下，如果内容一致则结果为真，否则结果为假
*   - 两者都是布尔值的情况下，如果值一致则结果为真，否则结果为假
*   - 两者都是对象引用的情况下，如果引用的是同一个对象则结果为真，否则结果为假
*   相等运算， 由于会进行隐式数据类型转换，所以其执行方式更为复杂。
*   - x与y的数据类型相同时，与全等运算的结果相同。
*   - x与y的数据类型不同时，判定规则如下:
*     - 一方为null值，另一方为undefined值的情况下，结果为真
*     - 一方为数值，另一方为字符串值的情况，将字符串转换为数值之后对数值进行比较
*     - 一方为布尔值，另一方为数值的情况，将布尔值转换为数值之后对数值进行比较
*     - 一方为布尔值，另一方为字符串值的情况，将两者都转换为数值后对数值进行比较
*     - 一方为数值，另一方为对象引用的情况，将对象引用转换为数值后对数值进行比较
*     - 一方为字符串值，另一方为对象引用的情况下，将对象引用转换为字符串值后对字符串的内容进行比较
*     - 以上六种情况之外的运算结果都为假。
* - 比较运算符
*   规则:
*   - 一方为数值，另一方为可以被转换为数值的数据类型的情况，将其转换为数值类型后在进行大小比较
*   - 如果操作数中含有NaN则结果为假
*   - 一方为字符串值，另一方为可以被转换为字符串值的数据类型的情况，将其转换为字符串值后再对字符串值进行大小比较。
*   - 操作数中有无法被转换为数值及字符串值的值，或是转换结果为NaN的情况，运算的结果为假。
* - in 运算符
*   in是一种用于检验属性是否存在的运算符，其运算符结果为布尔值。
* - instanceof运算符
*   instanceof是一种用于类型判断的运算符，其运算结果为布尔值。
* - 逻辑运算符
* - 位运算符
*   &           按位与(AND)
*   |           按位或(OR)
*   ^           按位异或(XOR)
*   <<          左移
*   >>          右移
*   >>>         无符号右移(最左位被置为0)
*   ~           单目运算符。按位取反，取1的补码
* - 赋值运算符
* - 算术运算符
* - 条件运算符
* - typeof运算符
* - new运算符
* - delete运算符
* - void运算符
* - 逗号运算符
* - 点运算符和中括号运算符
* - 函数调用运算符
* -
* */
